
# イントロ

ここでは、塩基配列のペアワイズローカルアライメントのソフトウェアを
seed-and-extendアプローチを用いて実装する際に必要になる、semi-globalアライメントの
動的計画法のアルゴリズムを考える。

近年の実用的なlocal alignmentを計算するソフトウェアは、そのほとんどが
seedの列挙とseedの伸長の2つのステージから構成され、seed-and-extend法と呼ばれる [1]。
代表的なものにBasic Local Alignment Search Tool (BLAST) [2] がある。

BLASTのextendのステージでは、Smith-Waterman-Gotohのアルゴリズム (SWG) [3, 4] を
semi-globalに書き換え、X-dropと呼ばれるヒューリスティックを取り入れた特徴的な
DPのアルゴリズム [5] を使用している。これはマトリクスを1セルずつ (1行ごとに左端のセルから)
計算するとき、既に計算したマトリクス内のスコアの最大値を保存しておき、
次に計算するセルのスコアがその最大値-X未満になったことをトリガにして伸長を終了するアルゴリズムである。
ここではBLASTで用いられるDPのアルゴリズムをX-drop DPと呼ぶ。
類似のアルゴリズムにbanded DP [6] と呼ばれるものがある。これは、globalアライメントや
semi-globalアライメントにおいて、DPマトリクスを一定の形 (多くは斜め45度の矩形)
に切り取り、その内部のみスコアを計算するものである。これはsemi-globalのDPに適した
ヒューリスティックで、多くのライブラリ [7, 8] やアプリケーション [9, 10, 11] に利用されている。


(X-drop DPやbanded DPによる計算領域の削減とは) 別のアプローチに、Single-Instruction-Multiple-Data
(SIMD)命令を使ったデータレベルの並列計算の利用がある。SIMD命令を使うと、複数 (8個や16個) の
セルに対する計算を並列に実行することができる。
protein配列のfull DPの計算をSIMD命令を使って高速化する手法は、Wozniakのアルゴリズム [12]、
Rognesのアルゴリズム [13]、Farrarのアルゴリズム [14] など、いくつかの方法が提案されている。
この中でも特にFarrarのアルゴリズム [14] は、多くの塩基配列のペアワイズローカルアライメントの
アプリケーション [15, 16] やライブラリ [8] に応用されている。
SIMD命令を使った並列アルゴリズムとbanded DPの組み合わせも存在し、BWA-MEM [10] はseedの伸長に
Rognesのアルゴリズム [13] をbanded DPに修正したものを使用している。


近年のシーケンサの発展で、生成されるリードはますます長くなり、PacBioやONTのリードは数kbに達する [?]。
full DPはFarrarのアルゴリズムによって効率良く計算ができるが、時間計算量が O(|a||b|)
(|a|と|b|はDPに与える2本の配列の長さ) となるため、このような長い配列のアライメントには向かない。
banded DPは事前に埋める領域が決定される必要があり、エラーの多い長い配列、特に、ins / del rateが
偏っている配列では領域を適切に決定するのが難しい (もしくは、幅が十分でないと最適解を発見できない)。
X-drop DPはfull DPやbanded DPの欠点を解決しているが、SIMD命令を用いた並列な実装は存在せず、
最近のCPUの演算能力を使い切ることができない欠点を持つ。
シーケンサの出力するリード長はこれからさらに長くなっていくことが想定され、エラー率とリード長のトレードオフも、
完全に解決されるにはまだ時間がかかると考えられる。
このため、長い塩基配列のアライメントをターゲットにした、full DPやbanded DPより使いやすく、
X-drop DPより高速なアルゴリズムの需要は高い。

ここでは、banded DPとX-drop DPを参考にした、dynamic banded DPのアルゴリズムを提案する。
これはbanded DPと同様に斜めのバンドの内部を計算するアルゴリズムで、バンドを1セル伸長する
ごとに進む方向を動的に決定するアルゴリズムである。動的に埋めるセルを決定する手法は
X-drop DPに類似しているが、バンドの幅が一定に固定されている点はX-drop DPとは異なる。
このアルゴリズムは、2本の塩基配列のペアワイズアライメントを、マッチ-ミスマッチモデルや
4 x 4の置換行列のモデルで計算する場合にSIMD命令を用いて実装でき、既存の類似手法と比較して
効率の良い計算できることを示す。
次に、recallや計算速度などを既存のX-drop DPや
いくつかのSIMD命令で並列化したbanded DPの実装と比較し、dynamic banded DPの特徴を明らかにする。


# メソッド

以下ではペアワイズsemi-globalアライメントのアルゴリズムを考える。これはSWGのアルゴリズム
[2, 3] の初期値の設定を修正したもので、開始端 (左上の端) は固定、終了端 (右下の端) は
自由としたものである。
また、スコアを計算する際のギャップペナルティには、線形ギャップペナルティモデルと
アフィンギャップペナルティモデルの2種類を考える。


## semi-globalアライメントのアルゴリズム

線形ギャップコストにおける、semi-globalアライメントのアルゴリズムの再帰式を
以下に示す。

アフィンギャップコストにおける、semi-globalアライメントのアルゴリズムの再帰式を
以下に示す。

## X-dropのアルゴリズム

X-drop DPのアルゴリズム [4] は、BLAST [1] で実装された。DPマトリクスを反対角線
方向に伸びるバンドに切り、これを左上のバンドから順に計算する。バンド内のセルは右上から
順に計算する。以前に計算したすべてのセルのスコアの最大値(S_max)を保持しておく。
バンドの両端の、スコアがS_max - Xより小さい部分を削り取ることでバンドの幅を調整
する。以下に、ncbi blastnのgapped alignmentの実装 (blast_SemiGappedAlign)
を元に記述したアフィンギャップコストのアライメントを計算する疑似コードを示す。

## dynamic banded DP

オリジナルのbanded DPはChao et.al. [5]によって提案された。このアルゴリズムは
一般にDPマトリクスをある形に切り取り、計算領域を狭めるアルゴリズムと解釈できる。
ここでは、DPマトリクスを斜め45度の矩形に切り取るもののみを考え、これをbanded DPと呼ぶ。
banded DPにおいて、バンドを反対角線方向に切った断面に並ぶセルのセット (vector)をlane
と呼ぶ。(メモ: laneと呼んでいるがもう少し良い呼び方があったら変えたい) このlaneの長さを
数をバンド幅と呼ぶ。

banded DPにおいて、バンド内のセルを計算する方法はいくつか考えられる。横方向もしくは縦方向に
スライスする方法はX-drop DPに類似した方法で、SeqAn [6] やSSW library [7]
のbanded DPで実装されている。BWA-MEM [9] で実装されたSSE2命令を使った
SIMD banded DPもこのような計算順序をとっている。
別の計算順序として、1レーンごとに端から計算する方法が考えられる。これはWozniak [11] により、
SIMD命令を導入して並列化したアルゴリズムに用いられた方法と同じである。Wozniakによる実装は
proteinのアライメントをターゲットにしており、置換行列をひく (retrieveする) 処理が
並列化できないという欠点があった。
塩基配列のアライメントでは一般にmatch / mismatchのモデル、もしくは4 x 4の置換行列で十分であるため、
この欠点は解消できる。
match / mismatchを検出し、それぞれのセルにどちらかの定数をロードする演算は、vectorに対する
compare equal命令とblend命令の組み合わせ (多くの環境で2命令)、もしくはSSE2で利用出来るshuffle命令
(pshufb命令 1命令) を使って高速に計算することができる。
4 x 4の置換行列のretrieveも、2塩基のペアを4bitで表現することで16セルのshuffleに帰着するため、
SSE2が利用できる環境では、pshufb命令を使って1命令で計算することができる。
Kimura [15] はこの性質をうまく利用し、bit-parallel edit-distanceアルゴリズムをbanded DPに
変形したものを提案した。

dynamic banded DPは、banded DPをlaneごとに計算する方法を使用する。各laneを計算するごとに
laneの端のセル同士を比較し、右上の方がスコアが大きければ右に、左下の方がスコアが大きければ下に
次のlaneを配置する。上で述べた通り、塩基配列の置換行列は、proteinの置換行列と比べて高速にretrieveできる
ため、ここでは塩基配列の置換行列に限定したアルゴリズムを考える。
伸長の終了判定は、X-drop DPに似た方法を用いる。laneの中央のセルの最大値を記録し、最後に計算した
laneの中央のセルのスコアがそれよりXだけ減少したら伸長をやめる。
このアルゴリズムの疑似コードを以下に示す。


# 実装

X-dropのアルゴリズムはncbi blastnの実装をベースにした。
dynamic banded DPはx86_64アーキテクチャのSSE2命令セットを使用し、16ビット幅のセルを
8セル同時に計算する実装とした。バンド幅は8の倍数でコンパイル時に決定できるものにした。

# 結果

## recallベンチマーク

blast X-drop DPとdynamic banded DPに配列ペアを与え、同じスコアを返すかをチェックする
ベンチマークを行った。配列ペアは、pbsimを使ってE.coli NC_000913のリファレンス配列から
simulated long readをモデルベースで生成し、リファレンス配列の対応する区間を切り出して
作成した。pbsimに与えるパラメータは、リード長と塩基の一致率を、それぞれ
100bp〜10kbp、65%〜95%の範囲で変化させた。
pbsimに与えたすべてのパラメータと生成されたリードのプロファイルを図に示す。

ここで生成したリードを、blast X-drop DPとdynamic banded DPに与えてスコアを計算した。
DPのスコア行列とギャップコストは、2つの整数 (x, y) を2 <= x <= 6と2 <= y <= 10
の範囲で変化させ、linear-gap costの実装には(M, X, G) = (2, -x, -y)、
affine-gap costの実装には(M, X, Gi, Ge) = (2, -x, -y, -2)を与えた。
dynamic banded DPのバンド幅は8〜64の範囲で変化させた。X-dropのスレッショルドは
60*giとした。


### バンド幅-一致率プロット

1kbpの配列ペアを与え、バンド幅を[8, 64]で、配列一致率を[0.6, 0.95]で変化させた
結果を図1aに示す。それぞれの数字はblastの実装とddiagの実装で同じスコアを報告した
ものの数で、右のかっこ内はddiagがblastと同じ、もしくはより高いスコアを報告した
ものの数を示す。アライメントに用いるスコア行列とギャップコストは、
(M, X, G) = (2, -4, -4)とした。
バンド幅が狭いもの (8, 16, 24) は一致率が低いときにblastとは異なる結果を返した。
これはバンド幅が狭いせいでアライメントパスが最適パスを外れたためと考えられる。
バンド幅が32以上のときは一致率によらずすべての場合でblastと同じ結果を返した。
スコアを(M, X, Gi, Ge) = (2, -4, -4, -2)としたアフィンギャップコストでも
同様の傾向を示した。(図1b)

[0.6, 0.65, 0.7, ..., 0.95] : error_rates
[8; 16; 24; ...; 64] : bandwidths
l[2, 2, :, :, 3] = 
array([[ 497,  692,  846,  958,  984,  999, 1000, 1000],
       [ 991,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図1a : linear

a[2, 2, :, :, 3] = 
array([[ 487,  703,  849,  944,  981,  999, 1000, 1000],
       [ 997,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図1b : affine

### エラー率-配列長プロット

バンド幅を16および32について、一致率を[0.6, 0.95]で、配列長を[100, 10k]で
変化させた結果を図2a (linear) と図2b (affine) に示す。
スコアは図1と同じものを使用した。
バンド幅が16では、配列長が長く一致率が低いときに異なる結果を返した。
バンド幅が32では、配列長や一致率にかかわらずどちらのアルゴリズムでも同じ結果を
返すことが確認できた。

[100, 200, 500, 1000, 2000, 5000, 10000] : lengths
[0.6; 0.65; ...; 0.95] : error_rates
16
l[2, 2, 1, :, :] = 
array([[1000,  998,  997,  991,  971,  924,  885],
       [1000, 1000,  998,  997,  995,  973,  975],
       [1000, 1000,  999, 1000,  998,  998,  997],
       [1000, 1000, 1000, 1000, 1000,  999, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])

32
l[2, 2, 3, :, :] = 
array([[1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図2a : linear


16
a[2, 2, 1, :, :] = 
array([[ 999, 1000,  999,  997,  985,  952,  928],
       [1000, 1000,  999,  997,  996,  984,  982],
       [1000, 1000, 1000, 1000, 1000,  999,  999],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])

32
a[2, 2, 3, :, :] = 
array([[1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図2b : affine

### x-giプロット

バンド幅を32に、一致率を0.75に、配列長を1kに固定し、xを[-2, -8]で、
giを[-2, -12]で変化させた結果を図3に示す。
gi = -2かつxが-2に近いとき (表右上) は一致率が低下するが、ddiag >= blastとなる
割合は低下しない。giとxがともに小さい (絶対値が大きい: 表右下) ときは、
一致率とddiag >= blastとなる割合がともに下がる。
アライメントがlinear phaseとなるスコアの組み合わせを濃いハッチで示し、
一致率が0.75のときにungapped alignmentのスコアの期待値が負となるスコアの
組み合わせを薄いハッチで示した。log phaseに入り、期待値が正となるスコアの
組み合わせでは、ddiagはblastと同じもしくはblastより良い結果を返すことがわかる。
一致率が低いスコアの組み合わせのうち、
左上の領域から(M, X, G) = (2, -2, -4)および(M, X, Gi, Ge) = (2, -2, -4, -2)を、
右下の領域から(M, X, G) = (2, -3, -5)および(M, X, Gi, Ge) = (2, -3, -5, -2)
について、(blastのスコア) - (ddiagのスコア) のヒストグラムを図4に示す。
左上の領域では、linearとaffineともに、スコア差は0〜5程度の間に分布した。
これはddiagがblastより少し良い結果を報告していることを示す。右下の領域では
linearとaffineともにスコア差は-10〜0程度の間に分布した。

[-2, -3, ..., -9] : x
[-2; -3; ...; -13] : gi
l[:, :, 3, 3, 3] = 
array([[ 927,  976,  999,  996,  994,  999,  999],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000,  999,  998],
       [1000, 1000, 1000,  999,  999,  997,  989],
       [1000,  999, 1000,  996,  992,  988,  982],
       [1000, 1000,  989,  987,  979,  976,  971],
       [ 998,  994,  990,  980,  970,  961,  959]])
図3a : linear

a[:, :, 3, 3, 3] = 
array([[ 927,  976,  999,  996,  994,  999,  999],
       [ 993, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000,  999],
       [1000, 1000, 1000, 1000, 1000, 1000,  999],
       [1000, 1000, 1000, 1000,  998,  991,  991],
       [1000, 1000, 1000,  998,  995,  983,  974]])
図3b : affine

### indel耐性

一致率を0.75、配列長を1000として生成したデータのリファレンス側およびリード側の
いずれかに、長さLの{A, C, G, T}が等確率でランダムに並んだ配列を[100, 600]
のランダムな位置に挿入したデータを作成した。Lは[0, 63]で変化させた。
スコアを(M, X, G) = (2, -4, -4)および(M, X, Gi, Ge) = (2, -4, -4, -2)とし、
バンド幅を[8, 64]に変化させてblastとdynamic banded DPとで同じ結果が得られるかを
調べた。この結果を図5に示す。
linearもaffineも挿入長さがBW-4程度まではほぼblastと同じ結果を得たが、それ以上の
挿入長さでは急激に一致率が低下した。

[8, 16, 24, ..., 64] : bandwidths
[0; 1; 2; ...; 63]
l_gap[:, 0, :, 3, 3] = 
array([[ 937, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 935, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 940,  999, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 954, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 945, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 948, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 926, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 871, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 659, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 478, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 334, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 245, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 155,  998, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 104,  992, 1000, 1000, 1000, 1000, 1000, 1000],
       [  75,  965, 1000, 1000, 1000, 1000, 1000, 1000],
       [  57,  915, 1000, 1000, 1000, 1000, 1000, 1000],
       [  52,  773, 1000, 1000, 1000, 1000, 1000, 1000],
       [  33,  599, 1000, 1000, 1000, 1000, 1000, 1000],
       [  37,  470, 1000, 1000, 1000, 1000, 1000, 1000],
       [  21,  350, 1000, 1000, 1000, 1000, 1000, 1000],
       [  16,  249,  997, 1000, 1000, 1000, 1000, 1000],
       [  15,  173,  990, 1000, 1000, 1000, 1000, 1000],
       [  10,  137,  968, 1000, 1000, 1000, 1000, 1000],
       [   9,   85,  911, 1000, 1000, 1000, 1000, 1000],
       [   6,   76,  829, 1000, 1000, 1000, 1000, 1000],
       [   4,   66,  676, 1000, 1000, 1000, 1000, 1000],
       [   5,   34,  519, 1000, 1000, 1000, 1000, 1000],
       [   2,   33,  410, 1000, 1000, 1000, 1000, 1000],
       [   1,   24,  290,  998, 1000, 1000, 1000, 1000],
       [   0,   27,  248,  987, 1000, 1000, 1000, 1000],
       [   0,   21,  166,  985, 1000, 1000, 1000, 1000],
       [   3,   15,  116,  935, 1000, 1000, 1000, 1000],
       [   2,   11,   97,  854, 1000, 1000, 1000, 1000],
       [   0,   10,   70,  743, 1000, 1000, 1000, 1000],
       [   1,    8,   55,  596, 1000, 1000, 1000, 1000],
       [   0,    4,   41,  478, 1000, 1000, 1000, 1000],
       [   0,    4,   38,  373,  999, 1000, 1000, 1000],
       [   0,    5,   25,  279,  992, 1000, 1000, 1000],
       [   0,    3,   29,  229,  977, 1000, 1000, 1000],
       [   0,    4,   19,  170,  926, 1000, 1000, 1000],
       [   0,    0,   10,  111,  878, 1000, 1000, 1000],
       [   0,    5,   11,   89,  800, 1000, 1000, 1000],
       [   0,    6,   13,   61,  638, 1000, 1000, 1000],
       [   0,    1,    3,   59,  575,  995, 1000, 1000],
       [   0,    2,    6,   45,  386,  996, 1000, 1000],
       [   0,    0,    9,   35,  320,  993, 1000, 1000],
       [   0,    1,    4,   30,  237,  975, 1000, 1000],
       [   0,    1,    6,   24,  210,  951, 1000, 1000],
       [   0,    1,    3,   19,  159,  907, 1000, 1000],
       [   0,    0,    2,   13,  129,  812, 1000, 1000],
       [   0,    0,    1,   13,  101,  719, 1000, 1000],
       [   0,    0,    4,    9,   71,  614,  999, 1000],
       [   0,    0,    0,   10,   48,  507,  996, 1000],
       [   0,    1,    0,    0,   37,  399,  990, 1000],
       [   0,    0,    1,    6,   39,  299,  982, 1000],
       [   0,    0,    1,    4,   25,  257,  968, 1000],
       [   0,    0,    0,    5,   33,  175,  927, 1000],
       [   0,    0,    0,    1,   13,  139,  834, 1000],
       [   0,    0,    1,    6,   14,  140,  770, 1000],
       [   0,    0,    0,    4,    8,   82,  617,  999],
       [   0,    0,    0,    4,    8,   73,  572,  997],
       [   0,    0,    0,    3,    9,   58,  470,  992],
       [   0,    0,    0,    0,    9,   50,  359,  987],
       [   0,    1,    0,    1,    5,   35,  280,  973]])
図5a : linear

a_gap[:, 0, :, 3, 3] = 
array([[ 945, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 950, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 940,  999, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 943, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 939, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 946, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 921, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 836, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 628, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 420, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 293, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 227, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 139,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 105,  992, 1000, 1000, 1000, 1000, 1000, 1000],
       [  79,  969, 1000, 1000, 1000, 1000, 1000, 1000],
       [  62,  887, 1000, 1000, 1000, 1000, 1000, 1000],
       [  43,  701, 1000, 1000, 1000, 1000, 1000, 1000],
       [  34,  478, 1000, 1000, 1000, 1000, 1000, 1000],
       [  24,  351, 1000, 1000, 1000, 1000, 1000, 1000],
       [  19,  250, 1000, 1000, 1000, 1000, 1000, 1000],
       [  20,  192,  996, 1000, 1000, 1000, 1000, 1000],
       [  23,  127,  990, 1000, 1000, 1000, 1000, 1000],
       [   6,  105,  964, 1000, 1000, 1000, 1000, 1000],
       [   5,   74,  896, 1000, 1000, 1000, 1000, 1000],
       [   4,   61,  737, 1000, 1000, 1000, 1000, 1000],
       [   8,   56,  543, 1000, 1000, 1000, 1000, 1000],
       [   7,   37,  383, 1000, 1000, 1000, 1000, 1000],
       [   6,   31,  272,  999, 1000, 1000, 1000, 1000],
       [   3,   35,  198,  997, 1000, 1000, 1000, 1000],
       [   1,   18,  151,  987, 1000, 1000, 1000, 1000],
       [   5,   14,  105,  976, 1000, 1000, 1000, 1000],
       [   0,   11,   88,  903, 1000, 1000, 1000, 1000],
       [   1,    9,   58,  787, 1000, 1000, 1000, 1000],
       [   3,   11,   54,  604, 1000, 1000, 1000, 1000],
       [   0,    2,   45,  427, 1000, 1000, 1000, 1000],
       [   1,    8,   32,  336,  999, 1000, 1000, 1000],
       [   1,    6,   31,  242,  997, 1000, 1000, 1000],
       [   0,    8,   21,  170,  991, 1000, 1000, 1000],
       [   0,    5,   19,  134,  960, 1000, 1000, 1000],
       [   0,    2,   21,  105,  901, 1000, 1000, 1000],
       [   0,    1,   15,   64,  807, 1000, 1000, 1000],
       [   0,    1,   12,   64,  656, 1000, 1000, 1000],
       [   0,    5,    5,   49,  483, 1000, 1000, 1000],
       [   0,    2,    7,   27,  384,  998, 1000, 1000],
       [   0,    2,    6,   28,  253,  999, 1000, 1000],
       [   0,    1,    2,   25,  163,  993, 1000, 1000],
       [   0,    0,    4,   20,  139,  959, 1000, 1000],
       [   0,    0,    4,   22,  114,  919, 1000, 1000],
       [   0,    0,    2,   17,   86,  827, 1000, 1000],
       [   0,    0,    3,   13,   68,  665, 1000, 1000],
       [   0,    0,    3,    8,   50,  520,  999, 1000],
       [   0,    0,    2,    5,   50,  436,  999, 1000],
       [   0,    0,    6,    7,   39,  311,  995, 1000],
       [   0,    0,    3,    4,   29,  223,  983, 1000],
       [   0,    0,    1,    5,   28,  157,  971, 1000],
       [   0,    0,    4,    4,   20,  119,  929, 1000],
       [   0,    0,    1,    3,   22,   94,  834, 1000],
       [   0,    0,    1,    1,   12,   69,  684, 1000],
       [   0,    0,    0,    4,   11,   64,  576, 1000],
       [   0,    0,    0,    2,    9,   43,  412, 1000],
       [   0,    0,    0,    0,   11,   44,  365,  999],
       [   0,    0,    0,    1,   10,   27,  244,  981],
       [   0,    0,    0,    0,    2,   25,  191,  969],
       [   0,    0,    1,    1,    8,   20,  126,  949]])
図5b : affine

## 速度ベンチマーク

スコアを(M, X, G) = (2, -4, -4)および(M, X, Gi, Ge) = (2, -4, -4, -2)、
バンド幅を32、一致率を0.75とし、配列長を[100, 10k]に変化させたデータを作成し、
スコアを出すまでの計算時間を測定した。

比較対象として、blast X-drop DP (blast)およびこれをSIMDで並列化したもの
(simdblast)、dynamic banded DP (ddiag)、およびSSW libraryの16ビットの実装 (ssw)
を用いた。また、参考として32セルdynamic banded DPについて、動的に方向を決定しないもの
(斜め45度のバンドを計算するもの) を、斜めに埋める方法 (diag) と横に埋める方法 (rognes)
で実装したものについても計算時間を測定した。図6に結果を示す。

linearではblastが最も遅いアルゴリズムとなった。SIMDで並列化したblast (simdblast)
は元のblastの実装より3倍程度高速になったが、dynamic banded DP (ddiag) はそれより
20%程度高速だった。SSWは短い配列長に対しては高速だが、DPマトリクスを全て計算する
アルゴリズムを実装しており、計算量が与える配列a、bの長さに対してO(|a||b|)で増加する。
結果もこの傾向を示しており、1kを超えるような長い配列に対してはddiagより遅くなった。
参考に含めたstaticバンドの2つの実装は、斜めに埋める方法 (diag) が横に埋める方法
(rognes) よりも高速で、ddiagの方がrognesより高速だった。

affineでも全体の傾向はlinearと同じだった。simdblastに対するddiagの高速化の割合は
50%程度で、linearよりも大きくなった。

図6a : linear

図6b : affine

# 考察

recallベンチマークの結果は、一致率0.75〜0.95、長さ1k〜10kの配列をスコア
(1, -2, -2, -1)でアライメントするといった、ロングリードのアライメントで一般的な
設定でdynamic banded DPがblast X-drop DPと実用上十分な程度に同じ結果を計算できる
ことを示している (図1、2)。実験では、(1, -1, -2, -1)といった、linear phaseとの
遷移境界に近いスコア行列と、スコアの期待値が負となるスコア行列でblastとddiagの
結果が一致しない割合が増加した (図3)。linear phaseとの境界近くではddiagが
blastより良い結果を示す傾向がある (図4) スコアの期待値が負となるスコア行列は実用上用いることが
ないので、この領域は無視してよい。

このような設定に対して、dynamic banded DPはblast X-drop DPより
典型的に7倍程度高速にスコアを計算することができる。blast X-drop DPとdynamic banded DPの
計算量はO(min(|a|, |b|))であり、これはSSW libraryに用いられているFarrarの
アルゴリズムのO(|a||b|)よりも良い。ベンチマークは[1k, 10k]程度の配列をアライメントする際、
ddiagはSSW libraryよりも高速にスコアを計算できることを示している。

blastとdynamic banded DPの結果が一致しない
スコアの組み合わせはほぼこの2つの領域にかぶっていて、これはこの2つの領域では
アライメントが安定しないためと考えられる。


dynamic banded DPはバンド幅が固定されているため、長いindelを挟んだ配列を捉えられない
欠点を持つ。ベンチマークはBW-4程度の長さまでは十分に捉えることができ、それより長いindelに
対しては急激にキャプチャ率が低下する。このような特性はindelを陽に考慮してアライメントする
ときに好ましい特性であり、キャプチャしたいindelの長さの分布が分かっている場合に
必要なバンド幅を決定できることを示している。

dynamic banded DPにおけるX-dropスレッショルドを、キャプチャできる最長のindelに対する
ペナルティと同じ程度になるように定めるとする。この値は32セル、(M, X, G) = (2, -4, -4)の
linearのとき110程度、(M, X, Gi, Ge) = (2, -4, -4, -2)のaffineのとき60程度となる。

この値はblastnのデフォルトのX-dropスレッショルド27 (bits)と同程度の値であり、
blastnでキャプチャできるアライメントを大きく損ねないことがわかる。(わかる???)

これらの結果から、dynamic banded DPは、これまでロングリードのDPに用いられてきた
blast X-drop DPやFarrarのアルゴリズムを置き換えることができるといえる。
また、このベンチマークでは一致率の上界を0.95としたが、さらに一致率の高いショートリード
(98〜99%程度) のリードに対しても問題なく適用できることが想定される。


# リファレンス

1. Li, Heng, and Nils Homer. "A survey of sequence alignment algorithms for next-generation sequencing." Briefings in bioinformatics 11.5 (2010): 473-483.
2. Altschull, Stephen F., et al. "Basic local alignment search tool." J. Mol. Biol 215 (1990): 403-410.
3. Smith, Temple F., and Michael S. Waterman. "Identification of common molecular subsequences." Journal of molecular biology 147.1 (1981): 195-197.
4. Gotoh, Osamu. "An improved algorithm for matching biological sequences." Journal of molecular biology 162.3 (1982): 705-708.
5. https://github.com/elucify/blast-docs/wiki/Gapped-Alignment-Phase "The Developer's Guide to BLAST: Gapped Alignment Phase"
6. Chao, Kun-Mao, William R. Pearson, and Webb Miller. "Aligning two sequences within a specified diagonal band." Computer applications in the biosciences: CABIOS 8.5 (1992): 481-487.
7. Döring, Andreas, et al. "SeqAn an efficient, generic C++ library for sequence analysis." BMC bioinformatics 9.1 (2008): 11.
8. Zhao, Mengyao, et al. "SSW library: An SIMD smith-waterman C/C++ library for use in genomic applications." (2013): e82138.
9. Lee, Wan-Ping, et al. "MOSAIK: a hash-based algorithm for accurate next-generation sequencing short-read mapping." PloS one 9.3 (2014): e90581.
10. Li, Heng. "Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM." arXiv preprint arXiv:1303.3997 (2013).
11. Chaisson, Mark J., and Glenn Tesler. "Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory." BMC bioinformatics 13.1 (2012): 238.
12. Wozniak, Andrzej. "Using video-oriented instructions to speed up sequence comparison." Computer applications in the biosciences: CABIOS 13.2 (1997): 145-150.
13. Rognes, Torbjørn, and Erling Seeberg. "Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors." Bioinformatics 16.8 (2000): 699-706.
14. Farrar, Michael. "Striped Smith–Waterman speeds database searches six times over other SIMD implementations." Bioinformatics 23.2 (2007): 156-161.
15. Li, Heng, and Richard Durbin. "Fast and accurate long-read alignment with Burrows–Wheeler transform." Bioinformatics 26.5 (2010): 589-595.
16. Langmead, Ben, and Steven L. Salzberg. "Fast gapped-read alignment with Bowtie 2." Nature methods 9.4 (2012): 357-359.

