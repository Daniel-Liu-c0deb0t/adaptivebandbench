
# イントロ

ここでは、ペアワイズローカルアライメントのソフトウェアを、seed-and-extend
アプローチを用いて実装する際に必要になる、semi-globalアライメントの
動的計画法のアルゴリズムを考える。ペアワイズローカルアライメントを動的計画法で
解くアルゴリズムとして、Smith-WatermanのアルゴリズムとGotohのアルゴリズム
がある。Semi-globalアライメントを計算するために、一般的にこれらのアルゴリズムを
開始端を固定端とするように修正したものが用いられる。このため、Smith-Watermanの
アルゴリズムを高速化したものをsemi-globalアライメントの高速化にも同様に
適用することができる。Single-instruction-multiple-data (SIMD)による
データレベルの並列計算を用いた並列化のアルゴリズムに、Rognesのアルゴリズムや
Farrarのアルゴリズムがある。これらは長方形のDPマトリクスを、複数のセルを
同時に計算することで高速に計算するアルゴリズムである。これらのアルゴリズムは
ライブラリに実装したものが公開されていて、これらはBWAなどの実用的なソフトウェアで
extensionのための動的計画法のルーチンとして用いられている。

一方、BLASTでは、動的計画法を高速化するために、動的計画法のマトリクスを効率よく
狭めるヒューリスティックアルゴリズムが取り入れられている。BLASTで使われるアルゴリズム
はX-dropと呼ばれる。これはマトリクス内のスコアの最大値を保存しておき、次に計算する
セルのスコアがその最大値-X未満になったことをトリガにして伸長を終了するアルゴリズムである。

X-dropを用いたDPは最適パスから離れたセルを計算しないため、特に長い配列を
アライメントする際に効果的なアルゴリズムであると考えられる。近年、PacBioやONTなどの
ロングリードを出力するシーケンサが増えてきていて、これらを高速にアライメントする
アルゴリズムの需要は高くなっている。

ここでは、X-drop DPのアイデアを取り入れた、バンド幅を固定したbanded DPのアルゴリズムを
提案する。このアルゴリズムをSIMD命令を用いて並列化して実装し、blastのX-drop DPと
速度やrecallなどの特徴を比較する。

# メソッド

以下ではペアワイズsemi-globalアライメントのアルゴリズムを考える。
また、スコアを計算する際のギャップペナルティには、線形ギャップペナルティモデルと
アフィンギャップペナルティモデルの2種類を考える。

## semi-globalアライメントのアルゴリズム

線形ギャップコストにおける、semi-globalアライメントのアルゴリズムの再帰式を
以下に示す。

アフィンギャップコストにおける、semi-globalアライメントのアルゴリズムの再帰式を
以下に示す。

## X-dropのアルゴリズム

X-dropのアルゴリズムは、最初にBLASTで実装された。DPマトリクスを反対角線方向に
伸びるバンドに切り、これを左上のバンドから順に計算する。バンド内のセルは右上から
順に計算する。以前に計算したすべてのセルのスコアの最大値(S_max)を保持しておく。
バンドの両端の、スコアがS_max - Xより小さい部分を削り取ることでバンドの幅を調整
する。以下に、ncbi blastnのgapped alignmentの実装 (blast_SemiGappedAlign)
を元に記述した疑似コードを示す。

## 固定幅banded DP

X-dropのアルゴリズムは、最適パスから離れたセルを計算しないようにする
ヒューリスティックだと捉えられる。最適パスから離れたセルを計算しないように、
DPマトリクス内に事前にバンドを定めたものをここではbanded DPと呼ぶ。
バンドの幅を、バンドを反対角線方向に切断した時に断面に並ぶセルの数と定義する。
また、バンドの幅が途中で変化するものを、特に可変幅banded DPと呼ぶ。バンドの幅が
変化しないものを固定幅banded DPと呼ぶ。

ここでは固定幅banded DPで、反対角線方向に一列に並んだセルをひとまとめにして
更新するアルゴリズムを考える。このアルゴリズムでは一列に並んだセルの間には
依存関係がないため、SIMD命令を用いて高速に計算することができる。伸長の終了判定は
blastのX-dropに似た方法を用いる。先端のバンドの中央のセルのスコアが
それまでのバンドの中央のセルのスコアの最大値よりXだけ減少したら伸長をやめる。



このアルゴリズムの疑似コードを以下に示す。


# 実装

X-dropのアルゴリズムはncbi blastnの実装をベースにした。
固定幅banded DPはx86_64アーキテクチャのSSE2命令セットを使用し、16ビット幅のセルを
8セル同時に計算する実装とした。バンド幅は8の倍数でコンパイル時に決定できるものにした。

# 結果

## recallベンチマーク

blast X-drop DPと固定幅banded DPに配列ペアを与え、同じスコアを返すかをチェックする
ベンチマークを行った。配列ペアは、pbsimを使ってE.coli NC_000913のリファレンス配列から
simulated long readをモデルベースで生成し、リファレンス配列の対応する区間を切り出して
作成した。pbsimに与えるパラメータは、リード長と塩基の一致率を、それぞれ
100bp〜10kbp、65%〜95%の範囲で変化させた。
pbsimに与えたすべてのパラメータと生成されたリードのプロファイルを図に示す。

ここで生成したリードを、blast X-drop DPと固定幅banded DPに与えてスコアを計算した。
DPのスコア行列とギャップコストは、2つの整数 (x, y) を2 <= x <= 6と2 <= y <= 10
の範囲で変化させ、linear-gap costの実装には(M, X, G) = (2, -x, -y)、
affine-gap costの実装には(M, X, Gi, Ge) = (2, -x, -y, -2)を与えた。
固定幅banded DPのバンド幅は8〜64の範囲で変化させた。X-dropのスレッショルドは
60*giとした。


### バンド幅-一致率プロット

1kbpの配列ペアを与え、バンド幅を[8, 64]で、配列一致率を[0.6, 0.95]で変化させた
結果を図1aに示す。それぞれの数字はblastの実装とddiagの実装で同じスコアを報告した
ものの数で、右のかっこ内はddiagがblastと同じ、もしくはより高いスコアを報告した
ものの数を示す。アライメントに用いるスコア行列とギャップコストは、
(M, X, G) = (2, -4, -4)とした。
バンド幅が狭いもの (8, 16, 24) は一致率が低いときにblastとは異なる結果を返した。
これはバンド幅が狭いせいでアライメントパスが最適パスを外れたためと考えられる。
バンド幅が32以上のときは一致率によらずすべての場合でblastと同じ結果を返した。
スコアを(M, X, Gi, Ge) = (2, -4, -4, -2)としたアフィンギャップコストでも
同様の傾向を示した。(図1b)

[0.6, 0.65, 0.7, ..., 0.95] : error_rates
[8; 16; 24; ...; 64] : bandwidths
l[2, 2, :, :, 3] = 
array([[ 497,  692,  846,  958,  984,  999, 1000, 1000],
       [ 991,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図1a : linear

a[2, 2, :, :, 3] = 
array([[ 487,  703,  849,  944,  981,  999, 1000, 1000],
       [ 997,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図1b : affine

### エラー率-配列長プロット

バンド幅を16および32について、一致率を[0.6, 0.95]で、配列長を[100, 10k]で
変化させた結果を図2a (linear) と図2b (affine) に示す。
スコアは図1と同じものを使用した。
バンド幅が16では、配列長が長く一致率が低いときに異なる結果を返した。
バンド幅が32では、配列長や一致率にかかわらずどちらのアルゴリズムでも同じ結果を
返すことが確認できた。

[100, 200, 500, 1000, 2000, 5000, 10000] : lengths
[0.6; 0.65; ...; 0.95] : error_rates
16
l[2, 2, 1, :, :] = 
array([[1000,  998,  997,  991,  971,  924,  885],
       [1000, 1000,  998,  997,  995,  973,  975],
       [1000, 1000,  999, 1000,  998,  998,  997],
       [1000, 1000, 1000, 1000, 1000,  999, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])

32
l[2, 2, 3, :, :] = 
array([[1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図2a : linear


16
a[2, 2, 1, :, :] = 
array([[ 999, 1000,  999,  997,  985,  952,  928],
       [1000, 1000,  999,  997,  996,  984,  982],
       [1000, 1000, 1000, 1000, 1000,  999,  999],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])

32
a[2, 2, 3, :, :] = 
array([[1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000]])
図2b : affine

### x-giプロット

バンド幅を32に、一致率を0.75に、配列長を1kに固定し、xを[-2, -8]で、
giを[-2, -12]で変化させた結果を図3に示す。
gi = -2かつxが-2に近いとき (表右上) は一致率が低下するが、ddiag >= blastとなる
割合は低下しない。giとxがともに小さい (絶対値が大きい: 表右下) ときは、
一致率とddiag >= blastとなる割合がともに下がる。
アライメントがlinear phaseとなるスコアの組み合わせを濃いハッチで示し、
一致率が0.75のときにungapped alignmentのスコアの期待値が負となるスコアの
組み合わせを薄いハッチで示した。log phaseに入り、期待値が正となるスコアの
組み合わせでは、ddiagはblastと同じもしくはblastより良い結果を返すことがわかる。
一致率が低いスコアの組み合わせのうち、
左上の領域から(M, X, G) = (2, -2, -4)および(M, X, Gi, Ge) = (2, -2, -4, -2)を、
右下の領域から(M, X, G) = (2, -3, -5)および(M, X, Gi, Ge) = (2, -3, -5, -2)
について、(blastのスコア) - (ddiagのスコア) のヒストグラムを図4に示す。
左上の領域では、linearとaffineともに、スコア差は0〜5程度の間に分布した。
これはddiagがblastより少し良い結果を報告していることを示す。右下の領域では
linearとaffineともにスコア差は-10〜0程度の間に分布した。

[-2, -3, ..., -9] : x
[-2; -3; ...; -13] : gi
l[:, :, 3, 3, 3] = 
array([[ 927,  976,  999,  996,  994,  999,  999],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000,  999,  998],
       [1000, 1000, 1000,  999,  999,  997,  989],
       [1000,  999, 1000,  996,  992,  988,  982],
       [1000, 1000,  989,  987,  979,  976,  971],
       [ 998,  994,  990,  980,  970,  961,  959]])
図3a : linear

a[:, :, 3, 3, 3] = 
array([[ 927,  976,  999,  996,  994,  999,  999],
       [ 993, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 999, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [1000, 1000, 1000, 1000, 1000, 1000,  999],
       [1000, 1000, 1000, 1000, 1000, 1000,  999],
       [1000, 1000, 1000, 1000,  998,  991,  991],
       [1000, 1000, 1000,  998,  995,  983,  974]])
図3b : affine

### indel耐性

一致率を0.75、配列長を1000として生成したデータのリファレンス側およびリード側の
いずれかに、長さLの{A, C, G, T}が等確率でランダムに並んだ配列を[100, 600]
のランダムな位置に挿入したデータを作成した。Lは[0, 63]で変化させた。
スコアを(M, X, G) = (2, -4, -4)および(M, X, Gi, Ge) = (2, -4, -4, -2)とし、
バンド幅を[8, 64]に変化させてblastと固定幅banded DPとで同じ結果が得られるかを
調べた。この結果を図5に示す。
linearもaffineも挿入長さがBW-4程度まではほぼblastと同じ結果を得たが、それ以上の
挿入長さでは急激に一致率が低下した。

[8, 16, 24, ..., 64] : bandwidths
[0; 1; 2; ...; 63]
l_gap[:, 0, :, 3, 3] = 
array([[ 937, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 935, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 940,  999, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 954, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 945, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 948, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 926, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 871, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 659, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 478, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 334, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 245, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 155,  998, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 104,  992, 1000, 1000, 1000, 1000, 1000, 1000],
       [  75,  965, 1000, 1000, 1000, 1000, 1000, 1000],
       [  57,  915, 1000, 1000, 1000, 1000, 1000, 1000],
       [  52,  773, 1000, 1000, 1000, 1000, 1000, 1000],
       [  33,  599, 1000, 1000, 1000, 1000, 1000, 1000],
       [  37,  470, 1000, 1000, 1000, 1000, 1000, 1000],
       [  21,  350, 1000, 1000, 1000, 1000, 1000, 1000],
       [  16,  249,  997, 1000, 1000, 1000, 1000, 1000],
       [  15,  173,  990, 1000, 1000, 1000, 1000, 1000],
       [  10,  137,  968, 1000, 1000, 1000, 1000, 1000],
       [   9,   85,  911, 1000, 1000, 1000, 1000, 1000],
       [   6,   76,  829, 1000, 1000, 1000, 1000, 1000],
       [   4,   66,  676, 1000, 1000, 1000, 1000, 1000],
       [   5,   34,  519, 1000, 1000, 1000, 1000, 1000],
       [   2,   33,  410, 1000, 1000, 1000, 1000, 1000],
       [   1,   24,  290,  998, 1000, 1000, 1000, 1000],
       [   0,   27,  248,  987, 1000, 1000, 1000, 1000],
       [   0,   21,  166,  985, 1000, 1000, 1000, 1000],
       [   3,   15,  116,  935, 1000, 1000, 1000, 1000],
       [   2,   11,   97,  854, 1000, 1000, 1000, 1000],
       [   0,   10,   70,  743, 1000, 1000, 1000, 1000],
       [   1,    8,   55,  596, 1000, 1000, 1000, 1000],
       [   0,    4,   41,  478, 1000, 1000, 1000, 1000],
       [   0,    4,   38,  373,  999, 1000, 1000, 1000],
       [   0,    5,   25,  279,  992, 1000, 1000, 1000],
       [   0,    3,   29,  229,  977, 1000, 1000, 1000],
       [   0,    4,   19,  170,  926, 1000, 1000, 1000],
       [   0,    0,   10,  111,  878, 1000, 1000, 1000],
       [   0,    5,   11,   89,  800, 1000, 1000, 1000],
       [   0,    6,   13,   61,  638, 1000, 1000, 1000],
       [   0,    1,    3,   59,  575,  995, 1000, 1000],
       [   0,    2,    6,   45,  386,  996, 1000, 1000],
       [   0,    0,    9,   35,  320,  993, 1000, 1000],
       [   0,    1,    4,   30,  237,  975, 1000, 1000],
       [   0,    1,    6,   24,  210,  951, 1000, 1000],
       [   0,    1,    3,   19,  159,  907, 1000, 1000],
       [   0,    0,    2,   13,  129,  812, 1000, 1000],
       [   0,    0,    1,   13,  101,  719, 1000, 1000],
       [   0,    0,    4,    9,   71,  614,  999, 1000],
       [   0,    0,    0,   10,   48,  507,  996, 1000],
       [   0,    1,    0,    0,   37,  399,  990, 1000],
       [   0,    0,    1,    6,   39,  299,  982, 1000],
       [   0,    0,    1,    4,   25,  257,  968, 1000],
       [   0,    0,    0,    5,   33,  175,  927, 1000],
       [   0,    0,    0,    1,   13,  139,  834, 1000],
       [   0,    0,    1,    6,   14,  140,  770, 1000],
       [   0,    0,    0,    4,    8,   82,  617,  999],
       [   0,    0,    0,    4,    8,   73,  572,  997],
       [   0,    0,    0,    3,    9,   58,  470,  992],
       [   0,    0,    0,    0,    9,   50,  359,  987],
       [   0,    1,    0,    1,    5,   35,  280,  973]])
図5a : linear

a_gap[:, 0, :, 3, 3] = 
array([[ 945, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 950, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 940,  999, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 943, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 939, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 946, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 921, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 836, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 628, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 420, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 293, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 227, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 139,  997, 1000, 1000, 1000, 1000, 1000, 1000],
       [ 105,  992, 1000, 1000, 1000, 1000, 1000, 1000],
       [  79,  969, 1000, 1000, 1000, 1000, 1000, 1000],
       [  62,  887, 1000, 1000, 1000, 1000, 1000, 1000],
       [  43,  701, 1000, 1000, 1000, 1000, 1000, 1000],
       [  34,  478, 1000, 1000, 1000, 1000, 1000, 1000],
       [  24,  351, 1000, 1000, 1000, 1000, 1000, 1000],
       [  19,  250, 1000, 1000, 1000, 1000, 1000, 1000],
       [  20,  192,  996, 1000, 1000, 1000, 1000, 1000],
       [  23,  127,  990, 1000, 1000, 1000, 1000, 1000],
       [   6,  105,  964, 1000, 1000, 1000, 1000, 1000],
       [   5,   74,  896, 1000, 1000, 1000, 1000, 1000],
       [   4,   61,  737, 1000, 1000, 1000, 1000, 1000],
       [   8,   56,  543, 1000, 1000, 1000, 1000, 1000],
       [   7,   37,  383, 1000, 1000, 1000, 1000, 1000],
       [   6,   31,  272,  999, 1000, 1000, 1000, 1000],
       [   3,   35,  198,  997, 1000, 1000, 1000, 1000],
       [   1,   18,  151,  987, 1000, 1000, 1000, 1000],
       [   5,   14,  105,  976, 1000, 1000, 1000, 1000],
       [   0,   11,   88,  903, 1000, 1000, 1000, 1000],
       [   1,    9,   58,  787, 1000, 1000, 1000, 1000],
       [   3,   11,   54,  604, 1000, 1000, 1000, 1000],
       [   0,    2,   45,  427, 1000, 1000, 1000, 1000],
       [   1,    8,   32,  336,  999, 1000, 1000, 1000],
       [   1,    6,   31,  242,  997, 1000, 1000, 1000],
       [   0,    8,   21,  170,  991, 1000, 1000, 1000],
       [   0,    5,   19,  134,  960, 1000, 1000, 1000],
       [   0,    2,   21,  105,  901, 1000, 1000, 1000],
       [   0,    1,   15,   64,  807, 1000, 1000, 1000],
       [   0,    1,   12,   64,  656, 1000, 1000, 1000],
       [   0,    5,    5,   49,  483, 1000, 1000, 1000],
       [   0,    2,    7,   27,  384,  998, 1000, 1000],
       [   0,    2,    6,   28,  253,  999, 1000, 1000],
       [   0,    1,    2,   25,  163,  993, 1000, 1000],
       [   0,    0,    4,   20,  139,  959, 1000, 1000],
       [   0,    0,    4,   22,  114,  919, 1000, 1000],
       [   0,    0,    2,   17,   86,  827, 1000, 1000],
       [   0,    0,    3,   13,   68,  665, 1000, 1000],
       [   0,    0,    3,    8,   50,  520,  999, 1000],
       [   0,    0,    2,    5,   50,  436,  999, 1000],
       [   0,    0,    6,    7,   39,  311,  995, 1000],
       [   0,    0,    3,    4,   29,  223,  983, 1000],
       [   0,    0,    1,    5,   28,  157,  971, 1000],
       [   0,    0,    4,    4,   20,  119,  929, 1000],
       [   0,    0,    1,    3,   22,   94,  834, 1000],
       [   0,    0,    1,    1,   12,   69,  684, 1000],
       [   0,    0,    0,    4,   11,   64,  576, 1000],
       [   0,    0,    0,    2,    9,   43,  412, 1000],
       [   0,    0,    0,    0,   11,   44,  365,  999],
       [   0,    0,    0,    1,   10,   27,  244,  981],
       [   0,    0,    0,    0,    2,   25,  191,  969],
       [   0,    0,    1,    1,    8,   20,  126,  949]])
図5b : affine

## 速度ベンチマーク

スコアを(M, X, G) = (2, -4, -4)および(M, X, Gi, Ge) = (2, -4, -4, -2)、
バンド幅を32、一致率を0.75とし、配列長を[100, 10k]に変化させたデータを作成し、
スコアを出すまでの計算時間を測定した。

比較対象として、blast X-drop DP (blast)およびこれをSIMDで並列化したもの
(simdblast)、固定幅banded DP (ddiag)、およびSSW libraryの16ビットの実装 (ssw)
を用いた。また、参考として32セル固定幅banded DPについて、動的に方向を決定しないもの
(斜め45度のバンドを計算するもの) を、斜めに埋める方法 (diag) と横に埋める方法 (rognes)
で実装したものについても計算時間を測定した。図6に結果を示す。

linearではblastが最も遅いアルゴリズムとなった。SIMDで並列化したblast (simdblast)
は元のblastの実装より3倍程度高速になったが、固定幅banded DP (ddiag) はそれより
20%程度高速だった。SSWは短い配列長に対しては高速だが、DPマトリクスを全て計算する
アルゴリズムを実装しており、計算量が与える配列a、bの長さに対してO(|a||b|)で増加する。
結果もこの傾向を示しており、1kを超えるような長い配列に対してはddiagより遅くなった。
参考に含めたstaticバンドの2つの実装は、斜めに埋める方法 (diag) が横に埋める方法
(rognes) よりも高速で、ddiagの方がrognesより高速だった。

affineでも全体の傾向はlinearと同じだった。simdblastに対するddiagの高速化の割合は
50%程度で、linearよりも大きくなった。

図6a : linear

図6b : affine

# 考察

recallベンチマークの結果は、一致率0.75〜0.95、長さ1k〜10kの配列をスコア
(1, -2, -2, -1)でアライメントするといった、ロングリードのアライメントで一般的な
設定で固定幅banded DPがblast X-drop DPと実用上十分な程度に同じ結果を計算できる
ことを示している (図1、2)。実験では、(1, -1, -2, -1)といった、linear phaseとの
遷移境界に近いスコア行列と、スコアの期待値が負となるスコア行列でblastとddiagの
結果が一致しない割合が増加した (図3)。linear phaseとの境界近くではddiagが
blastより良い結果を示す傾向がある (図4) スコアの期待値が負となるスコア行列は実用上用いることが
ないので、この領域は無視してよい。

このような設定に対して、固定幅banded DPはblast X-drop DPより
典型的に7倍程度高速にスコアを計算することができる。blast X-drop DPと固定幅banded DPの
計算量はO(min(|a|, |b|))であり、これはSSW libraryに用いられているFarrarの
アルゴリズムのO(|a||b|)よりも良い。ベンチマークは[1k, 10k]程度の配列をアライメントする際、
ddiagはSSW libraryよりも高速にスコアを計算できることを示している。

blastと固定幅banded DPの結果が一致しない
スコアの組み合わせはほぼこの2つの領域にかぶっていて、これはこの2つの領域では
アライメントが安定しないためと考えられる。


固定幅banded DPはバンド幅が固定されているため、長いindelを挟んだ配列を捉えられない
欠点を持つ。ベンチマークはBW-4程度の長さまでは十分に捉えることができ、それより長いindelに
対しては急激にキャプチャ率が低下する。このような特性はindelを陽に考慮してアライメントする
ときに好ましい特性であり、キャプチャしたいindelの長さの分布が分かっている場合に
必要なバンド幅を決定できることを示している。

固定幅banded DPにおけるX-dropスレッショルドを、キャプチャできる最長のindelに対する
ペナルティと同じ程度になるように定めるとする。この値は32セル、(M, X, G) = (2, -4, -4)の
linearのとき110程度、(M, X, Gi, Ge) = (2, -4, -4, -2)のaffineのとき60程度となる。

この値はblastnのデフォルトのX-dropスレッショルド27 (bits)と同程度の値であり、
blastnでキャプチャできるアライメントを大きく損ねないことがわかる。(わかる???)

これらの結果から、固定幅banded DPは、これまでロングリードのDPに用いられてきた
blast X-drop DPやFarrarのアルゴリズムを置き換えることができるといえる。
また、このベンチマークでは一致率の上界を0.95としたが、さらに一致率の高いショートリード
(98〜99%程度) のリードに対しても問題なく適用できることが想定される。


